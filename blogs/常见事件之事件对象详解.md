# 常见事件之事件对象详解

- https://blog.csdn.net/u012465377/article/details/38380037

## onMouseMove 事件

- window.onmousemove = this.onMouseMove;
> 如上代码正常情况下在我们认知中，该代码实现当鼠标在浏览器窗口上进行移动时将触发鼠标移动事件；
> 但实际上还有一种特殊情况， 当我们鼠先左键在浏览器窗口上按住部分，在weindow上进行移动将会触发鼠标移动事件这是合理的，但是呢同时我们移动到 window 之外 也就是浏览器之外时依然会继续触发该鼠标移动事件（厉害吧）；

## onMouseUp 事件

- 同 onMouseMove 当在 window 或者 document 绑定 onMouseUp 事件后， 在指定页面内按住鼠标移动到 浏览器外部，松开鼠标能够触发 onMouseUp 事件；

## onMouseUp 事件消失：

在做移动等操作时（需要先按住鼠标、然后通过移动鼠标进行相应操作、通过鼠标弹起结束操作）， 但是在个别情况下会发生 onMouseUp 事件丢失

### 原因一：触发了浏览器的 drag 操作，导致mouseup丢失；

- 鼠标按下（mousedown） + 鼠标移动（mousemover） 触发 drag 事件导致 mouseup 事件丢失
- 解决办法：在绑定 mousedown 时阻止事件冒泡、事件默认行为，从而阻止 drag 事件的发生； 即使想实现的本来就是 drag 操作，也可以通过创建跟随鼠标移动的dom元素实现效果。

```js
/**
 * 取消默认行为 阻止冒泡
 * @param {Object} e 事件对象
 */
pauseEvent(e){
  if(e.stopPropagation) e.stopPropagation();
  if(e.preventDefault) e.preventDefault();
  e.cancelBubble=true;
  e.returnValue=false;
  return false;
}
/**
 * 鼠标按下事件
 * @param {Object} e 事件对象
 */
onMouseDown = (e) => {
  this.pauseEvent(e);
  this.clientY = e.clientY;
  this.dragY = true;
}
```

### 原因二： 由于鼠标离开了操作的区域，触发了 mouseleave 导致 mouseup 丢失。（待确认）

- 由于鼠标移到了区域外，触发了 mouseleave 操作
- 解决办法：通过监听 mouseleave 操作，当触发该操作时可以停止或者还原状态。

## 补充

- mouseenter 与 mouseleave事件

在前端开发中，我们经常遇到隐藏弹出层或下拉菜单的需要。这就是所谓的显隐效果。我们经常使用mouseenter和mouseleave来实现。为什么不用mouseover和mouseout来实现呢，我来说一下这个问题：假设弹出层里面有无数子孙元素，我们的mouseout只监听弹出层最外面的大容器，我们很容易就移出这个大容器（鼠标移动到大容器的子元素，对于mouseout来说也算移出），但是实际上在鼠标还是在大容器范围内，会让判断失效。但mouseleave就不会，只有鼠标跑到大容器的外面才会触发，这是因为mouseenter和mouseleave不会冒泡。

# HTML5文件上传

文件上传基本上可以分为：html5文件上传、flash文件上传; html5文件上传主要是指通过使用 h5 新特性（File、 XMLHttpRequest2、FileReader、 FormData等）实现文件的上传；flash文件上传主要是借用 flash 接口实现文件上传;而本文主要是对 html5文件上传进行简单的介绍；

## 文件上传控件的实现

### 单文件上传

- 通过设置 inpout type 属性即可实现单上传文件控件

```html
<!-- 单文件上传 -->
<input type="file" />
```

### 多文件上传

- 在单文件上传控件的基础之上添加属性 multiple 实现多文件上传

```html
<!-- 多文件上传 -->
<input type="file" multiple="multiple" />
```

### 文件夹上传

#### 控件实现

- 在多文件上传控件的基础之上添加属性 webkitdirectory directory 实现文件夹上传控件

```html
<!-- 文件夹上传（只能选择文件夹进行上传并且兼容性并不是很好） -->
<input type="file" multiple="multiple" webkitdirectory directory  />

```

#### 补充说明

- 实际上在大多数浏览器上只需设置 webkitdirectory 即可，看有些地方也加上了 directory 属性所以就蛮加上去；
- webkitdirectory 属性的兼容性并不是很好（IE浏览器都不支持）
- 检测浏览器是否支持 webkitdirectory 属性：

```js
// 判断浏览器是否支持 webkitdirectory 属性
isSupport = () => {
  var input = document.createElement("input");
  input.type = "file";
  return !!("webkitdirectory" in (input))
}
```

- 在低版本 react 中并不支持 webkitdirectory directory 属性， 即使使用驼峰的写法也会被当做 props 进行处理；
- 在低版本 react 中可以通过下面的代码为 input 添加 webkitdirectory directory 属性

```js
// 不同 react 版本对 ref 的使用方式上也许有所不同，但总体上思路是一样的： 通过 ref 手动为 input 添加属性
componentDidMount() {
  if (this.refs.x) {
    this.refs.x.directory = true;
    this.refs.x.webkitdirectory = true;
  }
}
```

### 自定义上传控件样式：

- 要知道 input 上传控件在不同浏览器上的默认样式都是不同的，而且也都丑不拉几的；所以大多情况下我们都不会采用默认样式，而是自定义自己的控件；
- 自定义上传控件的样式也很简单：
  **方法一： 将 input 上传控件的透明度设置为 0后通过定位等手段覆盖在任意区块之上实现自定义上传控件**

```html

```

  **方法二： 通过 label 标签包裹任意区块并指向指定的 input 控件实现自定义上传控件**

```html

```

- 手动触发 label 触发 input 文件上传控件

## 通过 change 事件监听文件上传并获取 inputDom.files

- inputDom 在选择上传文件后将触发 change 事件；
- input 控件设置 type = 'file' 后， inputDom 将会具有一个 files 属性， 该属性是元素选择文件后返回的 FileList 对象； FileList 并不是真正的数组而是一个伪数组， 实际上是一个对象（key值为 0,1，2....）
- 通过设置　webkitdirectory　进行文件夹上传，　获取到的是文件夹下所有文件对应的 file 对象；

```js
const dom = document.getElementById('inout_file');
dom.onchange = function(e){
  // 获取 file 对象后就可以通过 XMLHttpRequest 传给后端
  const files = e.target.files;
}
```

## files 简介：

### 简介

支持File API的浏览器有：IE10+,Firefox3.5+，Opera10.6+，Safari5+,Chrome。
文件(File) 接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。通常情况下， File 对象是来自用户在一个 \<input\> 元素上选择文件后返回的 FileList 对象, 也可以是来自由拖放操作生成的 DataTransfer 对象，或者来自 HTMLCanvasElement 上的 mozGetAsFile() API。

File 对象是特殊类型的 Blob， Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。

### 获取到的 file 对象属性说明：

- lastModified： 最后修改时间戳
- lastModifiedDate： 最后上传时间(只使用于Chrome浏览器)
- webkitRelativePath：　文件的路径，相对于用户在 `<input />` 元素中选择的目录（只有在选择文件夹上传时才有值）
- name：　文件名
- size: 大小
- type：　文件类型

### 处理 file 对象的一些方法

对　file 对象的处理一般下列四种，但常用的基本也就　FileReader、　XMLHttpRequest；　FileReader　用于对　file 文件的读取， 通常用于图片上传中对图片进行预览； XMLHttpRequest 用于对文件进行上传， 同时 XMLHttpRequest 有 API 可以获取到文件上传的进度，用于文件上传进度条中；

- FileReader: 允许Web应用程序异步读取存储在用户计算机上的文件的内容，使用 File 或 Blob 对象指定要读取的文件或数据。
- XMLHttpRequest.send(): 使用XMLHttpRequest (XHR)对象可以与服务器交互。您可以从URL获取数据，而无需让整个的页面刷新。这使得Web页面可以只更新页面的局部，而不影响用户的操作。XMLHttpRequest在 Ajax 编程中被大量使用。
- URL.createObjectURL(): URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。(这是一个实验中的功能)
- createImageBitmap()：ImageBitmap 接口表示能够被绘制到 `<canvas \>` 上的位图图像，具有低延迟的特性。运用 createImageBitmap() 工厂方法模式，它可以从多种源中生成。 ImageBitmap提供了一种异步且高资源利用率的方式来为WebGL的渲染准备基础结构。

### FileReader 相关介绍（读取到的图片是 data: URL 格式）

- 浏览器支持： IE10+, Firefox3.6+，Opera11.5+，Safari6+,Chrome 6；
- 属性
  - FileReader.error： 表示在读取文件时发生的错误；
  - FileReader.readyState： 表示FileReader状态的数字；

    | 常量名 |　值 |　描述 |
    | ------ | ------ | ------ |
    | EMPTY    | 0 | 还没有加载任何数据. |
    | LOADING  | 1 | 数据正在被加载. |
    | DONE     | 2 | 已完成全部的读取请求. |

  - FileReader.result 文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作；
- 方法
  - FileReader.abort()：中止读取操作。在返回时，readyState属性为 2;
  - FileReader.readAsArrayBuffer(): 开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象.
  - FileReader.readAsBinaryString(): 开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。
  - FileReader.readAsDataURL():开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容。(一般用于处理图片文件)
  - FileReader.readAsText(): 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。（一般用于处理文本文件）
- 事件
  - FileReader.onerror: 该事件在读取操作发生错误时触发。
  - FileReader.onabort: 该事件在读取操作被中断时触发。
  - FileReader.onprogress: 该事件在读取Blob时触发。
  - FileReader.onloadstart: 该事件在读取操作开始时触发
  - FileReader.onloadend: 该事件在读取操作结束时（要么成功，要么失败）触发。
  - FileReader.onload: 该事件在读取操作完成时触发。

### XMLHttpRequest ProgressEvent 接口

XMLHttpRequest 具体的内容就不多做介绍，这里主要说下 Progress Event Progress Events定义了与客户端服务器通信有关的事件。这些事件最早其实只针对XHR操作，但目前也被其它API借鉴。具体的有以下几个事件：

- loadstart：在接收到相应数据的第一个字节时触发。
- progress：在接收相应期间持续不断触发。
- error：在请求发生错误时触发。
- abort：在因为调用abort()方法而终止链接时触发。
- load：在接收到完整的相应数据时触发。
- loadend：在通信完成或者触发error、abort或load事件后触发。

在这里重点说下progress事件， 该事件会在浏览器接收新数据期间周期性地触发。而onprogress事件处理程序会接收到一个event对象，其target属性是XHR对象，但包含着三个额外的属性：lengthComputable、loaded和total。其中，lengthComputable是一个表示进度信息是否可用的布尔值，loaded表示已经接收的字节数，loaded表示根据Content-Length响应头部确定的预期字节数。有了这些信息，我们就可以为用户创建一个进度指示器了。（需要特别说明的是 **GET请求和POST请求中绑定progress事件的方式有些许差别，GET是直接在XHR上进行绑定，POST则是在XML.upload上进行绑定的，具体看下面例子**）下面展示了为用户创建进度指示器的一个示例。

```js
// 创建 XHR
function createXHR() {
  if (typeof XMLHttpRequest != "undefined") {
      return new XMLHttpRequest();
  } else if (typeof ActiveXObject != "undefined") {
    if (typeof arguments.callee.activeXString != "string") {
      var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"];
      for (var i = 0, len = versions.length; i < len; i++) {
        try {
          var xhr = new ActiveXObject(versions[i]);
          arguments.callee.activeXString = versions[i];
          return xhr;
        } catch (ex) {
          //跳过
        }
      }
    }
    return new ActiveXObject(arguments.callee.activeXString);
  } else {
    throw new Error("NO XHR object available.")
  }
}

var xhr = createXHR();

// 绑定 onload事件
xhr.onload = function () {
  if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
    alert(xhr.responseText);
  } else {
    alert("Request was unsuccessful: " + xhr.status);
  }
};

// 特别注意在 post 请求中需要在 xhr.upload 上监听 onprogress 事件
xhr.upload.onprogress = function(e) {
  if (e.lengthComputable) {
    console.log(e.loaded / e.total * 100)
  }
}

//  GET 直接在 xhr 上绑定 onprogress 事件
// xhr.onprogress = function (event) {
//   var divStatus = document.getElementById("status");
//   if (event.lengthComputable) {
//     divStatus.innerHTML = "Recived" + event.loaded + " of " + event.total + " bytes";
//   }
// }

xhr.open("get", "altevents.php", true);
xhr.send(null);
```

## 一个小 Demo: 文件预览

- 上传文件，并绑定 change 事件， 获取 file 对象，并进行处理；
- 使用 FileReader 对 file 进行读取并进行处理；

```html
<input id="inout_file" type="file" />
<div id="preview"></div>
```

```js
const inoutFile = document.getElementById('inout_file');
const preview = document.getElementById('preview');

inoutFile.onchange = function(e){
  // 获取 file 对象后就可以通过 XMLHttpRequest 传给后端
  const files = e.target.files;
  getFile(files[0], preview);
}

getFile = (file, dom) => {
  const reader = new FileReader();
  let type = '';
  // 该事件在读取操作完成时触发。
  reader.onload = () => {
    if(type=='image'){
      // 图片： data: URL 格式
  　  var html="<img src=\" "+reader.result+" \">";
  　} else if(type='text'){
      // 文字
  　  var html=reader.result
  　}
    dom.innerHTML=html;
  }
  if(/image/.test(file.type)){
　　reader.readAsDataURL(file);
　　type='image';
  }else{
　　read.readAsText(file);
　　type='text';
  }
}
```

## Formdata 对象

FormData对象用以将数据编译成键值对，以便用XMLHttpRequest来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据(keyed data)，而独立于表单使用。

- 方法
  - append
  - delete
  - entries
  - get
  - getAll
  - has
  - keys
  - set
  - values

### fetch 暂时无法实现

## fetch 实现

- fetch 异常处理有点不同
- 参考：https://blog.csdn.net/sinat_24070543/article/details/81024259

```js
const formData = new FormData()
formData.append('file', file)

fetch(url,{
  method :"POST",
  body: formData,
  // 记得设置请求头(如果报 `Multipart: Boundary not found` 错请尝试把请求头删除)
  headers:{
    "Content-Type": "multipart/form-data"
  }
})
```

## 文件唯一标识： md5js 库

```js
var md5code = md5(file);
```

## 分片

## axios 实现 文件上传，进度条

```js
// axios 文件上传 并通过 onUploadProgress 事件获取进度
const fd = new FormData()
fd.append('file', params.file)
let config = {
  onUploadProgress: progressEvent => {
    var complete = (progressEvent.loaded / progressEvent.total * 100 | 0)
    console.log(complete)//进度值
      this.jindu = complete
  },
  headers: {
    'Content-Type': 'multipart/form-data'
  }
}

axios.post(uploadUrl, fd, config).then( res => {

}).catch( res => {

})


```

## axios 取消请求的两种方式

### 方法一: 使用 CancelToken.source 工厂方法创建 cancel token

```js
// axios 取消请
var CancelToken = axios.CancelToken;
var source = CancelToken.source();

axios.get('/user/12345', {
  cancelToken: source.token
}).catch(function(thrown) {
  if (axios.isCancel(thrown)) {
    console.log('Request canceled', thrown.message);
  } else {
    // 处理错误
  }
});

// 取消请求（message 参数是可选的）
source.cancel('Operation canceled by the user.');
```

### 方法二: 通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：

```js
var CancelToken = axios.CancelToken;
var cancel;

axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // executor 函数接收一个 cancel 函数作为参数
    cancel = c;
  })
});

// 取消请求
cancel();
```

## 如何实现真正的文件上传

## 补充

```js
// 读取图片
var img = document.createElement("img");
var reader = new FileReader();
reader.onload = function(e) {
  img.src = e.target.result;
}
reader.readAsDataURL(file);
```

```js
// 打开窗口预览图片(有缺陷)
window.open(window.URL.createObjectURL(record.file));

```

```js
// 模拟 a 标签进行下载
<a href="url 302到下载地址" download>下载</a>
```

### 文件上传压缩

- 通过 jsZip 这个库实现前端对文件的压缩上传（下载），支持向添加文件目录
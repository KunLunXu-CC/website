# 纯正

## 一、 开始一个小程序项目

### 1.1 下载微信开发者工具

### 1.2 注册账号

- 访问： https://mp.weixin.qq.com/
- 注册账号（账号类型选择小程序）
- 注册后进行登录
- 登录后进入设置页面（如果需要可对账号进行简单的设置），选择开发设置并获取 AppID
- 补充说明：一个账号只能选择一个服务类型（服务号、订阅号、小程序、企业微信）， 同时一个账号只能绑定一个服务；也就是如果我们需要进行小程序开发的话，那么一个账号只能对应一个小程序；

### 1.3 使用微信开发者工具创建项目

- 打开微信开发者工具并进行登录
- 选择小程序项目
- 如果已有项目则会进入项目列表，选择添加项目
- 填写项目信息，项目模板选择 "建立普通快速启动模板"
- 补充说明：微信开发工具主要由模拟器、编辑器、调试器三大块组成， 个人主要用于替代浏览器作为调试用；编辑器主要还是使用自己熟悉的编辑器（vscode）;更多有关微信开发工具的使用就不多作介绍；

## 二、 小程序基础知识

### 2.1 小程序的四种文件类型

- 样式文件（CSS）：wxss
  - 其实就是普通的CSS语法，无非就是多了一个 rpx 单位（750rpx等于屏幕宽度）
- 骨架文件(html)：wxml
- 除了标签和 html 不同，其他语法基本一样；
- 业务文件：js
- 配置文件：json
- 补充说明： 小程序开发并不是 web 开发，只是所用的知识基本相同，但是其实际底层原理是不同于 web 开发的;

### 2.2 项目基本结构

- 下面是使用微信开发者工具中"建立普通快速启动模板"选项创建的项目结构

```shell
├── app.js    # 全局 js 文件
├── app.json  # 全局样式文件
├── app.wxss  # 全局配置文件
├── pages     # 项目页面目录（该目录下一个目录代表一个页面）
│   ├── index          # index 页面
│   │   ├── index.js      # 页面 js 文件
│   │   ├── index.wxml    # 页面 wxml 文件
│   │   └── index.wxss    # 页面样式文件
│   └── logs           # logs 页面
│       ├── logs.js       # 页面 js 文件
│       ├── logs.json     # 页面配置文件
│       ├── logs.wxml     # 页面 wxml 文件
│       └── logs.wxss     # 页面样式文件 
├── project.config.json # 项目（环境）配置文件 （非必须）
└── utils        # 项目工具库（非必须）
    └── util.js
```

### 2.3 从零搭建项目 - 创建第一个页面

- 创建空白项目： 使用微信开发者工具创建项目不选择任何模板
- 创建空白项目将自动生成 project.config.json 项目配置文件
- 手动创建 app.json 全局配置文件： 配置文件内容如下（配置文件必须要有内容）

```json
{}
```

- 创建目录 pages/index
- 在微信开发者工具的编辑器中选中 pages/index 目录， 右键选择创建 page 并填写 page 名称
- 此时 pages/index/目录下将自动生成对应四种类型的文件，同时 app.json 中新增了 pages 配置项目， 并手动注册了一个页面；

```json
// app.json
{
  "pages": [
    "pages/index/index"
  ]
}
```

- 补充说明： 小程序中每个页面都需要进行手动在 app.json 的 pages 配置项中进行注册；并且 pages 项中默认第一个注册页面为首页；

### 2.4 app.json 配置项说明

> app.json 配置文件

- app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、tab配置 等。
- 主要配置配置项有： **pages**、**window**、 **tabBar** 更多的配置查阅小程序开发文档配置项下的全局配置。
> pages 配置项：

- 用于指定小程序由哪些页面组成，每一项都对应一个页面的。每项由 **路径+文件名** 组成, 文件名不需要写文件后缀，框架会自动去寻找相对于当前位置的 .json, .js, .wxml, .wxss 四个文件进行处理。
- 例：

```json
{
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ]
}
```

> window 配置项：用于设置小程序的状态栏、导航条、标题、窗口背景色。
- 配置导航栏样式：默认（default）、自定义（custom）： "navigationStyle": "default",
- 配置导航栏背景色： "navigationBarBackgroundColor": "#666",
- 设置导航栏标题内容： "navigationBarTitleText": "潜隐图书",
- 设置导航栏标题字体颜色： "navigationBarTextStyle":"white",
- 背景文字类型： dark / light （可控制下拉加载小点点的样式）："backgroundTextStyle":"dart",
- 窗体背景颜色（下拉加载更多时会显示该背景色）： "backgroundColor": "#ccc",
- 顶部窗口的背景色（下拉加载更多若设置了该值则以该参数为准）： "backgroundColorTop": "#f00",
- 底部窗口的背景色： "backgroundColorBottom": "#0f0",
- 是否全局开启下拉刷新。默认：false ： "enablePullDownRefresh": true,
- 页面上拉时，距页面底部多少距离触发触底事件，单位 px，默认 50： "onReachBottomDistance": 50
- 补充： navigationStyle 只在 app.json 中生效。开启 custom 后， 页面上导航部分不再被占用， 页面布局将置顶；但是低版本客户端需要做好兼容。
  
> tabBar 配置项： 如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。

- tab 字体颜色设置： "color": "#999"
- tab 选中时字体颜色设置： "selectedColor": "#33CCFF"
- tab 背景颜色设置： "backgroundColor": "#fff"
- tab 边框颜色设置 black / white： "borderStyle": "white"
- tab 定位设置 bottom / top： "position": "top"
- tab 每个 item 设置（数组）： list: { ... }
  - tabItem 文字内容： "text": "首页"
  - tabItem 文字前 icon： "iconPath": "",
  - tabItem 选中时 文字前 icon： "selectedIconPath": "",
  - tabItem 切换时所对应的页面（需在 pages 进行配置）： "pagePath": "pages/index/index"

## 三、 flex 布局

- 代码编写规范并不是固定不变的，在不同的团队其具有各自的代码规范，或者说是不同的代码风格
- view 组件类似与 div 标签， 是个块级组件；
- flex 容器将会消除 item 的块级特性: 如下代码， 子级区块在 flex 容器内将不再是块级容器，下面区块将具有 inline-block 特性；

```wxml
<view class="container">
  <view class="item color1"></view>
  <view class="item color2"></view>
  <view class="item color3"></view>
</view>
```

```wxss
.container{
  display: flex;
}
.item{
  width: 100px;
  height: 100px;
}
.color1{
  background: blue;
}
.color2{
  background: aqua;
}
.color3{
  background: brown;
}
```

- flex-direction 属性设置子级区块的排列方向：    设置主轴及其方向
  - row 行排序（一行行从左向右排列）
  - row-reverse 行倒序排列（一行行从右向左排列）
  - column 列排序（一列一列从上到下排列）
  - column-reverse 列倒序排列（一列一列从下到上进行排序）

- justify-content 属性设置子级区块在排序方向（主轴）上的对齐方式； 设置主轴上子元素的对齐方式
  - flex-start    对齐排序方向（主轴）的开头
  - flex-end      对齐排序方向（主轴）的末尾
  - center        子级区块居中
  - space-between 子级区块中间保留间隙
  - space-around  子级区块周边保留相同间隙（子区块间的间隙是首尾区块靠近边缘的两倍）
  - space-evenly  子级间距等分
  - 补充：flex-start flex-end 属性的实际效果受 flex-direction 属性值的影响；

- align-items  设置交叉轴上子元素的对齐方式
  - flex-start    对齐排序方向（交叉轴）的开头
  - flex-end      对齐排序方向（交叉轴）的末尾
  - center        子级区块居中
  - stretch       当元素未设置固定宽高时， 子元素会向交叉轴方向拉伸
  - baseline      按照元素内容中文字的基线对齐
- flex-wrap 设置子元素在排列时是否允许换行
  - wrap   运行换行
  - nowrap 不允许换行
  - 补充：换行的子元素将在剩余高度下进行垂直居中排列， 缩小 flex 容器高度即可; 

## 四、初识小程序组件

### 4.1 创建组件：

- 创建组件其实没什么特别的就想创建页面一样，创建四个不同类型的文件即可；
- 在项目根目录下创建 components 目录用于存储所有的组件；
- 创建 components/like 目录用于编写我们的第一个组件；
- 在微信开发工具中选中 comments/like 目录右键选择新建 component, 填写文件名称（这里我们统一用index命名）
- 如此会再项目下自动给我们生成四种基本类型的文件；

### 4.2 使用组件

- 引入组件： 在需要使用组件的页面下修改配置文件

```json
{
  // 配置页面下需要引入的自定义组件
  "usingComponents": {
    // 自定义组件名称： 组件的路径 
    "like-com": "/components/like/index"
  }
}
```

- 使用组件

```wxml
<like-com></like-com>
```

### 4.3 关于小程序单位的那些事：在设计稿按iPhone6(750 * 1334)来设计的情况下

- 使用单位 ps : 在样式中 px 的值为设计稿的 1/2；（假如设计搞值为 32px 那么在样式中实际应该只给 16px）
- 使用单位：rpx: 如果在样式中使用 rpx 单位，则rpx的值为设置搞中实际的 px 值；（假如设计搞值为 32px 那么在样式中实际值也为 32rpx）
- 所以理论上是推荐设计搞严格按照 iPhone6(750 * 1334) 来进行实际

### 4.4 小程序选择器

> 在小程序的文档中列出了有限个选择器，而实际上小程序所支持的选择器比文档上所列出的更多；在实际代码编写中若需要可自行尝试摸索；

### 4.5 全局样式设置

- 如果需要设置全局样式，可以在项目的根目录下（app.json 同级目录）创建全局样式文件 app.wxss
- 在微信小程序开发工具调试面板查看 wxml 会发现对于每个页面小程序会另外在最外层包裹一层 page 标签，所以在给小程序设置全局样式时可以技巧性的针对 page 进行设置全局样式；
- 在 app.wxss 样式文件中针对 page 标签设置全局样式

```css
page{
  font-size: 32rpx;
  color: #ccc;
}
```

### 4.6 在小程序中组件对样式的继承

- 在小程序组件中对样式进行了严格的把控，组件内部只会继承 fong 系列以及 color 样式其余样式都不会被继承；如下在 app.wxss 中设置了 background 但是绝对不会影响到 任何组件；

```css
.container{
  background: red;
}
```

### 4.7 like 组件的布局实现

```html
<!--components/like/index.wxml-->
<view class="container">
  <image src="./images/like2.png"></image>
  <text>9</text>
</view>
```

```css
.container{
  display: inline-flex;
  flex-direction: row;
  padding: 10rpx;
}

.container image{
  width: 32rpx;
  height: 28rpx;
}

.container text{
  font-size: 24rpx;
  line-height: 24rpx;
  color: #bbb;
  position: relative;
  bottom: 10rpx;
  left: 6rpx;
}
```

### 4.8 事件绑定： 更多查看文档 框架 => 模块 => 视图层 => WXML => 事件
  
- 小程序中点击事件为：tap
- 绑定事件使用关键词：
  - bind  : 事件绑定不会阻止冒泡事件向上冒泡。格式（bind:事件 = "函数名"）
  - catch : 事件绑定可以阻止冒泡事件向上冒泡。
- 对于业务逻辑处理（js）编写则需要在 js 中进行编写，在通过微信开发工具生成的组件或者页面会自动生成对应的 js 文件并给出完整的模板；

- WXML 中绑定事件， 当然 bind 可以改用 catch

```html
<view bind:tap="onLike" class="container">
  <image src="./images/like2.png"></image>
  <text>9</text>
</view>
```

- 在组件对应 js methods 中编写方法

```js
// components/like/index.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {

  },

  /**
   * 组件的初始数据
   */
  data: {

  },

  /**
   * 组件的方法列表
   */
  methods: {
    onLike: function(e){
      console.log(e);
    }
  }
})
```

### 4.9 组件的状态(data) 和 属性(properties)

- 在 js 中 data 中设置组件的状态（同 vue）
- 在 properties 中设置属性（类似 vue）
  - 在 properties 可通过 type 设置属性类型（必须）
  - 在 properties 可通过 value 设置属性的初始值（非必须，默认通过判断 type 值给定初始值）
  - 在 properties 可通过 observer 设置在属性值被更改时的响应函数；（非必须）
- 通过 this.data.xx 获取状态
- 通过 this.properties.xx 获取属性值；
- 通过 this.setData({}) 设置状态值 或者 属性值
- 在 WXML 中通过两层花括号使用属性或者状态值（类似 vue） 在花括号中支持 js 语句

### 4.10 完善 like 组件

- WXML

```html
<!--components/like/index.wxml-->
<view catch:tap="onLike" class="container">
  <image src="{{like ? yesSrc : noSrc}}"></image>
  <text>{{count}}</text>
</view>
```

- JS

```js
// components/like/index.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    like: {type: Boolean},
    count: {type: Number}
  },

  /**
   * 组件的初始数据
   */
  data: {
    yesSrc: './images/like2.png',
    noSrc: './images/like1.png'
  },

  /**
   * 组件的方法列表
   */
  methods: {
    onLike: function(e){
      let like = this.properties.like;
      let count = this.properties.count;
      let yesSrc =  this.data.yesSrc;
      this.setData({
        like: !like,
        count: like ? count -1 : count + 1
      });
    }
  }
})
```

## 五、 本地 koa 搭建服务： 编写模拟 API 、 设置静态服务存储图片

```js
const Koa  = require('koa');
const Router = require('koa-router');
const static = require('koa-static');
const router = new Router();

const app = new Koa();

router.get('/classic/latest', async (ctx, next) => {
  ctx.body = {
    content: '人生不能像做菜，把所有的材料都准备好才下锅',
    fav_nums: 11,
    id: 1,
    images: '',
    index: 7,
    like_status: 0,
    pubdate: '2018-06-22',
    title: '李安《饮食男女》',
    type: 100,
  };
});

router.get('/', async (ctx, next) => {
  ctx.body = {
    data: {name: 'qianyin', age: '20'},
    code: '1111111111'
  };
});

app.use(static(__dirname + '/static'));

app.use(router.routes()).use(router.allowedMethods());

app.listen(3000);
```

## 六、 wx.request 封装

```js
import { config } from '../config';
class http {

  request(params){
    if (!params){return ;}
    const {url = '/', data = {}, method = 'GET', success = () => {}} = params;
    wx.request({
      data,
      method,
      url: config.api_base_url + url,
      success: (res) => {
        console.log(`%c${method}: ${config.api_base_url + url}`, 'color: pink', res);
        if (res.statusCode === 200){
          success(res.data);
        } else {
          wx.showToast({
            title: '错误信息',
            icon: 'none',
            duration: 2000
          });
        }
      },
      fail: () => {
        wx.showToast({
          title: '错误信息',
          icon: 'none',
          duration: 2000
        });
      }
    });
  }
}

export default http;
```

## 七、 classic 页面绘制

### 7.1 classic 模型编写（封装请求方法）

```js
import http from '../utils/http';


class ClassicModel extends http{

  getClassisList(callback){
    this.request({
      url: '/classic/latest',
      success: callback
    });
  }


}
export default ClassicModel;
```

### 7.2 like组件的调用

- 在 onload 生命周期中获取数据设置data（onload生命周期最早触发）

```js
  onLoad: function (options) {
    classic.getClassisList(res => {
      this.setData({
        classicData: res
      });
    });
  },

```

- 通过属性为like组件设置值

```html
<view>
  <like-com
    like="{{classicData.like_status}}"
    count="{{classicData.fav_nums}}" ></like-com>
</view>
```

### 7.3 movie 组件的编写

- 通过微信开发工具创建组件；
- 简单编写并在页面进行调用；
- 编写组件 props

```js
  properties: {
    img: {type: String},
    content: {type: String}
  },
```

- 编写 wxml

```html
<!--components/classic/movie/index.wxml-->
<view class="classis-wrapper">
  <image class="bg-img" src="{{img}}" />
  <image class="tag-img" src="./img//电影。@2x.png" />
  <text class="content">{{content}}</text>
</view>
```

- 编写 wxss

```css
/* components/classic/movie/index.wxss */
.classis-wrapper{
  display: flex;
  flex-direction: column;
  align-items: center;
}
.bg-img{
  width: 750rpx;
  height: 500rpx;
}
.tag-img{
  width: 46rpx;
  height: 142rpx;
  position: relative;
  right: 300rpx;
  bottom: 60rpx;
}
.content{
  max-width: 500rpx;
  font-size: 32rpx;
  line-height: 2;
  text-indent: 2em;
  color: #666;
}
```

### 7.4 epsoide 组件编写

- 创建组件，并简单在页面上进行引用；
- 组件静态编写
- wxml

```html
<view class="container">
  <view class="index-container">
    <text class="plain">No.</text>
    <text class="index">08</text>
    <view class="line"></view>
  </view>
  <view class="date-container">
    <text class="month">七月</text>
    <text class="year">2018</text>
  </view>
</view>
```

- wxss

```

```
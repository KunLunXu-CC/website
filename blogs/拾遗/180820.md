#### 遗漏
- 文件上传原生实现；
- inputDom.files 
- file 对象
- FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据
- FileReader 对象
- blob 对象
- FormDate 对象
- 密码学
- 现代密码学教程
- cryptojs 加密库的使用

##### 加密 crypto-js AES 加解密
- 参考： 
https://www.jianshu.com/p/a47477e8126a
https://blog.csdn.net/vieri_32/article/details/48345023
https://blog.csdn.net/qq_28205153/article/details/55798628


```
var CryptoJS = require("crypto-js");
var key ="aaaabbbbccccddddeeeeffffgggghhhh";
var iv = "1234567812345678";

function encrypt(text){
    return CryptoJS.AES.encrypt(text,CryptoJS.enc.Utf8.parse(key),{
        iv:CryptoJS.enc.Utf8.parse(iv),
        mode:CryptoJS.mode.CBC,
        padding:CryptoJS.pad.Pkcs7
    })
}

function decrypt(text){
    var result = CryptoJS.AES.decrypt(text,CryptoJS.enc.Utf8.parse(key),{
        iv:CryptoJS.enc.Utf8.parse(iv),
        mode:CryptoJS.mode.CBC,
        padding:CryptoJS.pad.Pkcs7
    })
    return result.toString(CryptoJS.enc.Utf8)
}

var text="ni你好hao";
var encoded=encrypt(text)
console.log(encoded.toString());
console.log(decrypt(encoded))

```
```
在这里简单介绍下对称加密算法与非对称加密算法的区别。
对称加密算法
加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发送数据的场合。缺点是密钥的传输比较麻烦。
非对称加密算法
加密和解密用的密钥是不同的，这种加密方式是用数学上的难解问题构造的，通常加密解密的速度比较慢，适合偶尔发送数据的场合。优点是密钥传输方便。常见的非对称加密算法为RSA、ECC和EIGamal。
实际中，一般是通过RSA加密AES的密钥，传输到接收方，接收方解密得到AES密钥，然后发送方和接收方用AES密钥来通信。

```

#### 为 cookie 设置时间： 
```js
var d= new Date();
d.setHours(d.getHours() + (24 * 30)); //保存一个月
document.cookie = "visited=yes; expires=" + d.toGMTString();+ ';path =/';
```
#### 商品房加密后的密码：sYoXAjcG7LkHkU1jhaUgnw==

#### npm 命令
npm install --production 

添加了production  参数后将仅仅  安装  package.json 中dependencies 里面的包，不会安装devDependencies 里面的

#### 将本地已有项目发布到 github 
参考： https://blog.csdn.net/alex_my/article/details/78818957
##### 1.1 GitHub 上创建仓库：
- 创建仓库并获取到链接：https://github.com/qianyin925/blog.git
##### 1.2 初始化本地项目：
```shell
# 进入项目
$ cd blog/
# 初始化项目
$ git init
```
##### 1.3 本地仓库与远程仓库绑定
```shell
# 绑定，并取一个别名，通常用origin，后面的地址是前边创建的远程仓库地址
$ git remote add origin https://github.com/qianyin925/blog.git
# 于远程建立跟踪：
$ git push --set-upstream origin master
```
##### 1.4 上传内容：
```shell
$ git add .
$ git commit -m "...."
$ git push
```

#### 原生css
- div如何垂直居中
- rem使用
- 移动端适配策略
- 

#### 通过 ref.click() 手动触发事件

#### 在fetch 中 post 使用中 当body为formDate 时  需要手动设置请求头：
```js
// 只要随便设置其中一个即可， 一般设置 Content-Type 毕竟长度我们自己也不知道是多少
headers: {
	'Content-Type': 'multipart/form-data',
	'Content-Length': '35678'
},
```
#### form-Date content-Type
```js
前面一篇文章fetch已入过门，所以这只说重点，之前使用vue-resource和fetch时，在Conten-type设置上吃过不少亏，所以自己做了大量功课，重要的事情说三遍，post请求content-type,即数据请求的格式主要设置方式：

application/x-www-form-urlencoded（大多数请求可用：eg：'name=Denzel&age=18'）

multipart/form-data（文件上传，这次重点说）

application/json（json格式对象，eg：{'name':'Denzel','age':'18'}）

text/xml(现在用的很少了，发送xml格式文件或流,webservice请求用的较多)
```








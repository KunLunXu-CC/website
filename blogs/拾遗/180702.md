#### 后端对于未能查询到数据的则应该返回一个空数组或者对象

#### 做过的那些傻逼事：
```js
// 在通过filter对数据进行过滤时 一时手贱 写出下面代码
return rolesOpts.filter(item=>item.id = id)[0];
return rolesOpts.filter(item=>item.id === id)[0];
```




#### 
##### 
---
##### 编程
- 无错程序
- 算法优化
- 数据结构
- 程序流程设计
	- 面向对象
	- 函数式编程
	- 响应式编程
- 同步 / 异步  并发/并行
#### 系统分析
- 运用架构思想
- 领域分析能力：领域驱动设计
	- 链接：https://pan.baidu.com/s/1GrKiMpiqLrqrIPD0magH1Q 密码：wmh3
- 数据库设计
- 有状态和无状态、共享和非共享
- 事务和非事务
- 高可用性、一致性、最终一致性
- 应用场景分析
##### 思考：
- 技术找工作
- 工作学技术
- 编写程序思路: 各种方法编写位置（按功能在页面上的顺序进行摆放）
- 程序就像一个黑匣子 输入 ==> 输出
	- 不同输入  最终返回可控输出

####  git本地仓库不显示最新的远程仓库分支
```shell
git fetch 		#会把远程服务器上所有的更新都拉取下来
git pull 			#是把远程分支的代码拉取下来并合并到本地分支
git branch -r #查看分支
```

##### antd 选择器不能收缩问题：


##### 如果值不存在怎么办定律
在调用值前多考虑下假如值不存在怎么办？对象不存在呢？通过 ES6语法的解构语法来取值；


##### docker跑ngin
```shell
$docker pull ngin

```


```shell
# 随便起个容器
docker run -d -p 80:80 --name nginx  nginx 
# 容器之间相互拷贝方法
docker cp $PWD/nginx.conf b29d113e0e23:/etc/nginx
docker cp b29d113e0e23:/etc/nginx/nginx.conf $PWD
# 将容器nginx配置文件拷贝出来
# 删除容器
# 重新创建拷贝容器
docker run -d -p 80:80 --name main-server-nginx -v $PWD/html:/usr/share/nginx/html -v $PWD/conf/nginx.conf:/etc/nginx/nginx.cof -v $PWD/logs/var/log/nginx nginx


```


#### 下载安装：docker-ce 最新docker， ce表示 社区免费版
- 安装方法以官网为准；
- 安装文档查：https://docs.docker.com/install/linux/docker-ce/ubuntu/
- 设置源：
- https://blog.csdn.net/yhjay88/article/details/73790487?utm_source=itdadao&utm_medium=referral
- 重启docker: service docker restart命令重启服务。



#### 周四
---
##### 有状态和无状态
```
基本概念： 

有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。 

无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。

```
##### 
```
在分布式系统来说，如果不想牺牲一致性，CAP 理论告诉我们只能放弃可用性，这显然不能接受。为了便于讨论问题，先简单介绍下数据一致性的基础理论。

强一致

当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。

弱一致性

系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。

最终一致性

弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。
在工程实践上，为了保障系统的可用性，互联网系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性的保证，保证数据的最终一致性。但在电商等场景中，对于数据一致性的解决方法和常见的互联网系统（如 MySQL 主从同步）又有一定区别，群友的讨论分成以下 6 种解决方案。
```
```
CAP 定理
CAP 定理：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。

一致性
一致性指:更新操作成功后，所有节点在同一时间的数据完全一致。常见的一致性类别：

Weak（弱一致性）：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些 cache 系统。
Eventually（最终一致性）：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google 搜索引擎这样的系统。
Strong（强一致性）：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table 都是强一致性的。
```
```
强一致性 (Consistency)：系统在执行过某项操作后仍然处于一致的状态。在分布式系统中，更新操作执行成功后所有的用户都应该读取到最新的值，这样的系统被认为具有强一致性。
可用性 (Availability)：每一个操作总是能够在一定的时间内返回结果，超时和不能返回结果均不符合条件。
分区容错性(Partition Tolerance)：分区容错性可以理解为系统在存在网络分区的情况下仍然可以接受请求。这里网络分区是指由于某种原因网络被分成若干个孤立的区域，而区域之间互不相通。还有一些人将分区容错性理解为系统对节点动态加入和离开的处理能力，因为节点的加入和离开可以认为是集群内部的网络分区。
```

```
事务（Transaction）是并发控制单位，是用户定义的一个操作序列，这些操作要么都做，要么都不做，是一个不可分割的工作单位。
事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。
原子性
事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 。
一致性
事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。比如，当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统在运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。
隔离性
一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
持续性
指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。
事务中的所有操作要么全部执行，要么都不执行； 如果事务没有原子性的保证，那么在发生系统 故障的情况下，数据库就有可能处于不一致状态。 因而，事务的原子性与一致性是密切相关的。
```

##### 在住维打印中为 表格列设置了百分比宽度 ，但是最后几列发生变形；
- 主要原因是前面几列百分比太高 相加早已大于100 在有内容的时候发生设置的宽度就失去效果

##### react路由理解
Route其实姑且当作是一个组件。使用path属性指定与路由进行匹配的值，和路由匹配的结果作为Route的状态( 类似state 或者props )当状态(匹配结果改变时)重新渲染通过component指定的组件(类似state  和 props)
```jsx
// 例一：
/* 下面切换路由：http://localhost:3000/pay/page_1 http://localhost:3000/pay/page_2
<Route path ="/pay" component = { Page }/> 路由匹配状态（匹配结果并没有改变）所以不管如何切换路由也不会触发 Page 组件的重新渲染
*/
import React from 'react';
import { BrowserRouter as Router, Route, Link } from 'react-router-dom';

const RouterPage = (props) => {
    
  return (
    <Router>
      {/* Router 内的元素 组件都将被加载渲染 */}
      <div>
        <Link to="/pay/page_1">page_1</Link><br/>
        <Link to="/pay/page_2">page_2</Link>
        <Route path ="/pay" component = { Page }/>
      </div>
    </Router>
  );
}
export default RouterPage;

const Page = (props) => {
  return(
    <div>
      <Route path={`${props.match.url}/page_1`}  component={Page_1}/>
      <Route path={`${props.match.url}/page_2`}  component={Page_2}/>
      <Route path={`${props.match.url}/*`} component={PageCom}></Route>
    </div>
  );
}

class PageCom extends React.Component{
  componentDidMount(){
    console.log('=====组件渲染完毕======');
  }
  render(){
    return(
      <div>
        page
      </div>
    );
  }
}

class Page_1 extends React.Component{
  render(){
    return(
      <div>
        page_1
      </div>
    );
  }
}
class Page_2 extends React.Component{
  render(){
    return(
      <div>
        page_2
      </div>
    );
  }
}

```
```jsx
// 例二
/*
如下代码 来回切换路由/pay/page_1  /pay/page_2 并不会使得<Route path="/pay/*" component={pay}/>  重新渲染组件，因为其匹配结果不变 相当去状态并未发生改变 不会触发组件的变化
*/
import React from 'react';
import { BrowserRouter as Router, Route, Link } from 'react-router-dom';

const RouterPage = (props) => {
    
  return (
    <Router>
      {/* Router 内的元素 组件都将被加载渲染 */}
      <div>
        <Link to="/pay/page_1">page_1</Link><br/>
        <Link to="/pay/page_2">page_2</Link><br/>
        <Link to="/list">list</Link><br/>
        <Route path="/pay/*" component={pay}/>
        <Route path="/list" component={List}/>
      </div>
    </Router>
  );
}
export default RouterPage;

class pay extends React.Component{
  componentDidMount(){
    console.log("=====page 渲染=====");
  }
  render(){
    return (
      <div>
      page
      </div>
    );
  }
}

class List extends React.Component{
  componentDidMount(){
    console.log("=====list 渲染=====");
  }
  render(){
    return (
      <div>
        List
      </div>
    );
  }
}
```
























#### 一、样式修改 以及 权重
##### 1.1 
内联样式优先级高于外部引用样式. 

而脚本修改样式的语句又高于以上两种.所以,如果脚本里用到了object.style.xxxx='xxx';的话,那你只能再用脚本修改,

 !important 应该可以优先于内联样式.

通过style属性设置的样式 可以通过 !important进行重置

测试：脚本设置的样式能否被 !important修改覆盖

##### 1.2 修改 placeholder 样式

```css
input::-webkit-input-placeholder{
	color:red !important;
}
input::-moz-placeholder{   /* Mozilla Firefox 19+ */
	color:red !important;
}
input:-moz-placeholder{    /* Mozilla Firefox 4 to 18 */
	color:red !important;
}
input:-ms-input-placeholder{  /* Internet Explorer 10-11 */ 
	color:red !important;
}
```

#### 二、 npm install 报错
#### 2.1 
```shell
npm ERR! Unexpected token < in JSON at position 100080
npm ERR! A complete log of this run can be found in:
npm ERR!     /home/qianyin/.npm/_logs/2018-07-25T03_46_37_467Z-debug.log

```
解决办法： 删除 package-lock.json 文件


#### 三、 遗漏的知识：

cookie  token  session  localStore  ......

正则

#### 四、 react进阶？？？ 环境变量 npm script 原理？

#### 五、 router 研究心得
- 路由的变化切换并不是页面刷新！！！！！
- 只有 this.props 以及this.state发生变化(即便值还是原先的值)一样会造成组件的render
- 子组件的重新 render 不会造成父组件的render, 但会造成子组件的render；当然对兄弟组件也是么有影响的；
- Router 只作为普通组件来包裹组件；路由的变化并不会影响 Router 所包裹组件的组件的render
- Route 通过 path 属性来匹配路由， 匹配正确则加载渲染指定组件，同时可以通过this.props获取到路由参数信息；直白的说 当路由发生变化时，指定被渲染的组件必定 render ;因为this.props发生变化了；（当然 没被path匹配到的组件连渲染的机会都没）


#### 六、 组件渲染的尝试：
```jsx
// 为什么 antd Menu 的openKeys属性 可以直接修改引用数据，不需要使用this.setState() 不会使得 render 执行
class Test extends React.Component{
  constructor(){
    super();
    this.openKeys=['1', '2']
  }
  render(){
    console.log('------------ redner --------------');
    return (
      <div style={{width: '200px'}}>
        <Menu
          openKeys={this.openKeys}
          mode="inline"
          theme='dark'>
        {
          navSetting.map(v => (
              <Menu.SubMenu 
                onTitleClick={this.onTitleClick}
                title={v.title} key={v.key}>
                {
                  v.children.map(e => (
                    <Menu.Item key={e.key}>
                      {e.title}
                    </Menu.Item>
                  ))
                }
              </Menu.SubMenu>
          ))
        }
        </Menu>
      </div>
    );
  }

  onTitleClick = ({key, e}) => {
    const idx = this.openKeys.indexOf(key);
    idx === -1 ? this.openKeys.push(key) : this.openKeys.splice(idx, 1);
  }
  // onTitleClick = ({key, e}) => {
  //   const idx = this.openKeys.indexOf(key);
  //   const newKeys = JSON.parse(JSON.stringify(this.openKeys));
  //   idx === -1 ? newKeys.push(key) : newKeys.splice(idx, 1);
  //   this.openKeys = newKeys;
  // }
}

const navSetting = [
  {
    title: '子菜单一', 
    key: '0', 
    children: [
      {title: '菜单', key: '0-0'},
      {title: '菜单', key: '0-1'},
      {title: '菜单', key: '0-2'},
      {title: '菜单', key: '0-3'}
    ]
  },
  {
    title: '子菜单二', 
    key: '1', 
    children: [
      {title: '菜单', key: '1-0'},
      {title: '菜单', key: '1-1'},
      {title: '菜单', key: '1-2'},
      {title: '菜单', key: '1-3'}
    ]
  },
  {
    title: '子菜单三', 
    key: '2', 
    children: [
      {title: '菜单', key: '2-0'},
      {title: '菜单', key: '2-1'},
      {title: '菜单', key: '2-2'},
      {title: '菜单', key: '2-3'}
    ]
  },
  {
    title: '子菜单四', 
    key: '3', 
    children: [
      {title: '菜单', key: '3-0'},
      {title: '菜单', key: '3-1'},
      {title: '菜单', key: '3-2'},
      {title: '菜单', key: '3-3'}
    ]
  },
  {
    title: '子菜单五', 
    key: '4', 
    children: [
      {title: '菜单', key: '4-0'},
      {title: '菜单', key: '4-1'},
      {title: '菜单', key: '4-2'},
      {title: '菜单', key: '4-3'}
    ]
  },
];

```

```jsx
// 正常应该这样， 直接修改值不会引起 render 的执行(state也一样)，自然也不会引起子组件的 render 应该不会使得组件的重新渲染；
class Test extends React.Component{
  constructor(){
    super();
    this.data= {name: 'qianyin', age: 32};
  }
  render(){
    return (
      <div>
        <Pay data={this.data}></Pay>
        <Button onClick={this.onClick}>修改</Button>
      </div>
    );
  }

  onClick = () => {
    this.data = {
      name: 'qianyin',
      age:18
    };
  }
}

class Pay extends React.Component{
  render(){
    const {data} = this.props;
    return (
      <div>
        <p>name: {data.name}</p>
        <p>age: {data.age}</p>
      </div>
    );
  }
}
```
为什么要报错state的不可变呢？
参考文章：https://www.jianshu.com/p/c6257cbef1b1
总结一下，创建新的状态对象的关键是，避免使用会直接修改原对象的方法，而是使用可以返回一个新对象的方法。当然，也可以使用一些Immutable的JS库，如Immutable.js，实现类似的效果。
那么，为什么React推荐组件的状态是不可变对象呢？
一方面是因为不可变对象方便管理和调试，了解更多可参考这里；
另一方面是出于性能考虑，当对象组件状态都是不可变对象时，我们在组件的shouldComponentUpdate方法中，仅需要比较状态的引用就可以判断状态是否真的改变，从而避免不必要的render调用。当我们使用React 提供的PureComponent时，更是要保证组件状态是不可变对象，否则在组件的shouldComponentUpdate方法中，状态比较就可能出现错误，因为PureComponent执行的是浅比较（比较对象的引用）。

简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。
```jsx
constructor(){
	super();
	this.state={
    name: 'qianyin',
    arr:[],
    obj:{}
	}
}

// 对于基本类型(非引用类型)数据时，该怎么修改就怎么修改  状态肯定是不可变的
this.setState({name: 'linheng'});

// 对于引用类型（数组、对象）应该重新创建新的引用数据 
// 而不是在原先的引用数据上进行修改状态，保证数据的不变性
// 不推荐做法(在原先引用数据进行修改)
const arr = this.state.arr;
const obj = this.state.obj;
arr.push(value);
obj[key] = value;
this.setState({arr, obj});
// 推荐做法
const arr = [...this.state.arr, value];  // 创建一个新的数组
const obj = {...this.state.obj, key: value}; // 创建一个新的对象
this.setState({arr, obj});
```

#### 七、 关于this.setState 和 setTimeout  =====>  这是为什么呢？
- 说明： this.setState 和 setTimeout都是异步这是肯定的，那么 this,setState 和 setTimeout异步又好像又区分先后；实验得出 好像 this.setState 的异步优先与 setTimeout 执行; 所以可以通过 setTimeout来获取 this.setState修改的状态；
```jsx
// 下面的例子中 setTimeout 会在this.setState执行后才会执行，也就是说setTimeout中可以打印出 修改后 state 
setTimeout(()=>{
  console.log(this.state.name); // 打印出： qianyin
}, 0);
this.setState({name: 'qianyin'});
```

#### 八、 遗漏的小知识
##### 8.1 手动触发 resize 事件
```js
window.dispatchEvent(new Event('resize'));
```
##### 8.2 redux使用异步的时候，创建 action 的函数所返回的函数除了一个 dispatch 参数外 还有一个参数（getState） 可以获取到当前所有的 state
```js
const getUserList = () => {
  return (dispatch, getState) => {
  	axios.get('......'),then(res=>{
      // 获取当前的所有 state 内容；
      const state = getState():
      duspatch({
        type: xxxx,
        payload: {}
      })
  	}); 
  }
}
```
###### 8.3  sort()函数
说明：sort对数组进行排序
```js
// 依次两两取出值进行操作，执行比较器 当比较器返回正数则b将被调到a的前面，如果是负数a将被调到b之前，相等一般位置保持不变
[1,3,4,6,9].sort((a, b)=>{return a -b}) // [1, 3, 4, 6, 9]
[1,3,4,6,9].sort((a, b)=>{return b-a}) // [9, 6, 4, 3, 1]
```
##### 8.4 moogodb全局更新：
```js
// {multi: true}表示全局更新，否则只会查询第一条数据也只会更新一条数据
// { n: 1, nModified: 1, ok: 1 } 执行后返回内容：n表示查询到的数据条数，nModified表示操作的数据条数，ok表示操作成功的个数
chatModel.update(
    {from, to},
    {$set: {read: true}},
    {multi: true},
    (err, doc) => {
      if(!err){
        console.log(doc);
      }
    }
   );
```


































